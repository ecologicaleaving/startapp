# Story 1.2: Database Schema Implementation

## Status
Done

## Story
**As a** backend developer,  
**I want** to create optimized database tables for tournament and match caching,  
**so that** data can be stored efficiently with fast query performance

## Acceptance Criteria
1. `tournaments` table created with all required fields mapped from FIVB API
2. `matches` table created with foreign key relationship to tournaments
3. `sync_status` table created for monitoring synchronization health
4. All performance indexes created (tournament code, dates, status)
5. RLS policies configured for read/write access patterns
6. Data retention and cleanup functions implemented

## Tasks / Subtasks

- [ ] Create Database Tables (AC: 1, 2, 3)
  - [ ] Create `tournaments` table with all required fields from FIVB API mapping
  - [ ] Create `matches` table with foreign key relationship to tournaments.no
  - [ ] Create `sync_status` table for monitoring synchronization health
  - [ ] Create `schema_versions` table for tracking database schema changes

- [ ] Implement Performance Indexes (AC: 4)
  - [ ] Create index on tournaments.code for tournament lookup
  - [ ] Create index on tournaments.start_date for date-based queries
  - [ ] Create index on tournaments.status for status filtering
  - [ ] Create index on tournaments.last_synced for cache validation
  - [ ] Create index on matches.tournament_no for match retrieval
  - [ ] Create index on matches.local_date for date-based match queries
  - [ ] Create index on matches.status for live match filtering
  - [ ] Create index on matches.no_in_tournament for match ordering

- [ ] Configure Row Level Security (AC: 5)
  - [ ] Enable RLS on tournaments table
  - [ ] Create public read policy for tournaments (client access)
  - [ ] Create service role full access policy for tournaments (sync operations)
  - [ ] Enable RLS on matches table
  - [ ] Create public read policy for matches (client access)
  - [ ] Create service role full access policy for matches (sync operations)
  - [ ] Enable RLS on sync_status table
  - [ ] Create read-only policy for sync_status (monitoring access)
  - [ ] Create service role full access policy for sync_status (sync operations)

- [ ] Implement Data Retention and Cleanup (AC: 6)
  - [ ] Create cleanup_old_matches() function for data retention
  - [ ] Implement automatic timestamp triggers (update_last_synced function)
  - [ ] Create triggers for tournaments table timestamp updates
  - [ ] Create triggers for matches table timestamp updates
  - [ ] Schedule monthly cleanup job via cron extension

- [ ] Enable Real-Time Configuration
  - [ ] Add tournaments table to supabase_realtime publication
  - [ ] Add matches table to supabase_realtime publication
  - [ ] Test real-time subscriptions for data changes

- [ ] Create Migration Script and Initialize Data
  - [ ] Create comprehensive migration script with all tables, indexes, and functions
  - [ ] Insert initial sync_status records for tournaments, matches_schedule, and matches_live
  - [ ] Insert initial schema version record (1.0.0)
  - [ ] Execute migration using supabase migration system or manual SQL execution

## Dev Notes

### Previous Story Insights
From Story 1.1 completion:
- Migration-based approach established for reproducible database changes
- RLS policy functions already created in 001_enable_rls_and_realtime.sql migration
- Manual SQL execution required in Supabase Dashboard (automated setup script provides instructions)
- Supabase client configuration and connection testing already operational

### Database Schema Specifications
**Source: [database-schema.md]**

#### tournaments Table Structure
```sql
CREATE TABLE tournaments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  no VARCHAR NOT NULL UNIQUE,
  code VARCHAR,
  name VARCHAR,
  start_date DATE,
  end_date DATE,
  status VARCHAR,
  location VARCHAR,
  last_synced TIMESTAMP DEFAULT NOW(),
  version INTEGER DEFAULT 1,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
```

**FIVB API Field Mapping**:
- `no` → Tournament.No (primary identifier)
- `code` → Tournament.Code (tournament code like "MWBVT2025")  
- `name` → Tournament.Name (tournament display name)
- `start_date` → Tournament.StartDate (parsed from XML date format)
- `end_date` → Tournament.EndDate (parsed from XML date format)
- `status` → Tournament.Status (Running, Finished, etc.)

#### matches Table Structure  
```sql
CREATE TABLE matches (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  no VARCHAR NOT NULL,
  tournament_no VARCHAR NOT NULL,
  no_in_tournament VARCHAR,
  team_a_name VARCHAR,
  team_b_name VARCHAR,
  local_date DATE,
  local_time TIME,
  court VARCHAR,
  status VARCHAR,
  round VARCHAR,
  -- Score tracking fields
  match_points_a INTEGER,
  match_points_b INTEGER,
  points_team_a_set1 INTEGER,
  points_team_b_set1 INTEGER,
  points_team_a_set2 INTEGER,
  points_team_b_set2 INTEGER,
  points_team_a_set3 INTEGER,
  points_team_b_set3 INTEGER,
  -- Set duration fields  
  duration_set1 VARCHAR,
  duration_set2 VARCHAR,
  duration_set3 VARCHAR,
  -- Referee information
  no_referee1 VARCHAR,
  no_referee2 VARCHAR,
  referee1_name VARCHAR,
  referee2_name VARCHAR,
  referee1_federation_code VARCHAR,
  referee2_federation_code VARCHAR,
  -- Metadata
  last_synced TIMESTAMP DEFAULT NOW(),
  version INTEGER DEFAULT 1,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (tournament_no) REFERENCES tournaments(no) ON DELETE CASCADE
);
```

**FIVB API Field Mapping**:
- `no` → BeachMatch.No (unique match identifier)
- `tournament_no` → Foreign key to tournaments.no
- `no_in_tournament` → BeachMatch.NoInTournament  
- `team_a_name` → BeachMatch.TeamAName
- `team_b_name` → BeachMatch.TeamBName
- `local_date` → BeachMatch.LocalDate
- `local_time` → BeachMatch.LocalTime
- `court` → BeachMatch.Court
- Score fields map directly to corresponding BeachMatch fields

#### sync_status Table Structure
```sql
CREATE TABLE sync_status (
  entity_type VARCHAR PRIMARY KEY,
  last_sync TIMESTAMP,
  sync_frequency INTERVAL,
  next_sync TIMESTAMP,
  success_count INTEGER DEFAULT 0,
  error_count INTEGER DEFAULT 0,
  last_error TEXT,
  last_error_time TIMESTAMP,
  is_active BOOLEAN DEFAULT true,
  updated_at TIMESTAMP DEFAULT NOW()
);
```

**Initial Sync Records** [Source: database-schema.md#sync_status]:
- tournaments: daily sync frequency
- matches_schedule: 15-minute sync frequency  
- matches_live: 30-second sync frequency

### Performance Optimization Strategy
**Source: [database-schema.md#performance-optimization]**

#### Index Strategy
- Primary keys: UUID with B-tree indexes
- Foreign keys: Tournament references with cascade deletes  
- Query optimization: Separate indexes on commonly filtered fields
- Time-based queries: Indexes on date/time fields for chronological sorting

#### Common Query Patterns
- Recent tournaments: `WHERE start_date >= NOW() - INTERVAL '1 month'`
- Tournament matches: `WHERE tournament_no = $1 ORDER BY local_date, local_time`
- Live matches: `WHERE status = 'Running' AND local_date = CURRENT_DATE`
- Sync status check: `WHERE next_sync <= NOW() AND is_active = true`

### Row Level Security Configuration
**Source: [database-schema.md#row-level-security]**

#### Security Policy Patterns
- **Public read access**: Client applications can SELECT from tournaments and matches
- **Service role full access**: Background sync operations require ALL permissions  
- **Monitoring read access**: sync_status table accessible for monitoring dashboards

#### RLS Policy Implementation
Each table requires:
1. Enable RLS: `ALTER TABLE {table} ENABLE ROW LEVEL SECURITY`
2. Public read policy: `FOR SELECT USING (true)`  
3. Service role policy: `FOR ALL USING (auth.role() = 'service_role')`

### Data Retention and Cleanup Strategy  
**Source: [database-schema.md#data-retention-strategy]**

#### Retention Guidelines
- **tournaments**: Keep indefinitely for historical analysis, archive after 2 years
- **matches**: Keep for tournament duration + 6 months, then archive
- **sync_status**: Keep operational data, no archival needed

#### Cleanup Function Implementation
- `cleanup_old_matches()`: Monthly execution via cron
- Automatic timestamp updates via triggers
- Version tracking for conflict resolution

### Real-Time Configuration
**Source: [database-schema.md#real-time-configuration]**

#### Publication Setup
- Add tournaments to supabase_realtime publication
- Add matches to supabase_realtime publication  
- Enable WebSocket subscriptions for live data updates

### Cache Invalidation Strategy
**Source: [database-schema.md#cache-invalidation-strategy]**

#### TTL Guidelines
- tournaments: 24 hours (master data changes infrequently)
- matches_schedule: 15 minutes (schedules may change)
- matches_live: 30 seconds (live scores need frequent updates)

#### Automatic Triggers
- `update_last_synced()` function for timestamp management
- Triggers on UPDATE operations for cache validation

### Technical Constraints
**Source: [brownfield-architecture.yaml#technical_specifications]**

#### Version Compatibility Requirements
- PostgreSQL on Supabase platform
- Row Level Security must be enabled for all tables
- Real-time subscriptions capability required
- Cron extension available for scheduled cleanup

#### Integration Requirements  
- Foreign key relationships with CASCADE DELETE
- UUID primary keys for distributed system compatibility
- Version fields for optimistic locking and conflict resolution

### File Structure and Migration Approach
**Source: Previous Story 1.1 implementation**

#### Migration File Location
- Create new migration: `supabase/migrations/002_create_database_schema.sql`
- Follow established migration pattern from 001_enable_rls_and_realtime.sql
- Include comprehensive comments and defensive programming patterns

#### Execution Method
- Manual SQL execution in Supabase Dashboard (established pattern)
- Update setup script to reference new migration file
- Include validation queries to confirm successful creation

## Testing

### Unit Testing Requirements
**Source: [brownfield-architecture.yaml#testing_strategy]**

#### Schema Validation Tests
- Verify all tables created with correct field types and constraints
- Validate foreign key relationships and CASCADE DELETE behavior
- Test all indexes created and functioning correctly
- Confirm RLS policies block unauthorized access appropriately

#### Data Integrity Tests  
- Test INSERT, UPDATE, DELETE operations on all tables
- Verify timestamp triggers fire correctly on data changes
- Validate sync_status table tracks operations properly
- Test cleanup function removes appropriate old records

### Integration Testing Requirements

#### Database Connectivity Tests
- Verify Supabase client can connect and perform basic operations
- Test RLS policies with different authentication contexts (anon vs service_role)
- Validate real-time subscriptions receive change notifications
- Test performance with sample data load

#### API Compatibility Tests
- Verify database schema supports all FIVB API field mappings  
- Test data type compatibility for XML-to-database conversion
- Validate foreign key relationships maintain referential integrity
- Test query performance meets expected response time thresholds

### Testing Tools and Frameworks

#### Database Testing Approach
- Direct SQL testing via Supabase SQL Editor
- PostgreSQL-specific testing for constraints and triggers
- Real-time subscription testing via JavaScript client
- Performance testing with representative data volumes

#### Test Data Requirements
- Sample tournament records with various statuses and date ranges
- Sample match records with complete score and referee information
- Test sync_status records for different entity types and frequencies
- Edge cases: tournaments without matches, matches without tournaments (should fail)

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-08 | 1.0 | Initial story creation with comprehensive database schema requirements | Scrum Master |

## Dev Agent Record

### Agent Model Used
[To be populated by development agent]

### Debug Log References  
[To be populated by development agent]

### Completion Notes
[To be populated by development agent]

### File List
[To be populated by development agent]

## QA Results
[To be populated by QA agent]